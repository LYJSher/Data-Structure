# 线性表

## 顺序表

### 建表

#### 静态分配

~~~c
#define MAXSIZE 50 // 定义线性表的最大长度
typedef struct{
    ElemType data[MAXSIZE]; // 顺序表元素
    int length; // 顺序表当前长度
}SqList; //顺序表的类型定义
~~~

#### 动态分配

~~~c
#define INITSIZE 100 // 表长度的初始定义

typedef struct{
    ElemType *data; // 只是动态分配数组的指针
    int MaxSize, length; // 数组最大容量和当前个数
}SeqList;

// C的初始动态分配
L.data = (ElemType*)malloc(sizeof(ElemType)*INITSIZE);
// C++的初始动态分配
L.data = new ElemType[INITSIZE];
~~~

特点：随机访问

### 基本操作实现

#### 插入

~~~c
int ListInsert(SqListptr L, int i, ElemType e){
	if(i<1 || i>L->length+1) // 无效范围, 临界值可插在1位置和length+1位置处
		return 0;
	if(L->length >= MAXSIZE) // 存储空间已满
		return 0;
    int j;
	for(j=L->length; j>=i; j--)
		L->data[j] = L->data[j-1]; // 将第i个元素之后的元素后移
	L->data[i-1] = e; // 在位置i处放入e
	L->length++;
	return 1;
}
~~~

最好O(1) 最坏O(n) 

平均移动次数n/2 平均O(n)

#### 删除

~~~c
int ListDelete(SqListptr L, int i, ElemType *e){
	if(i<1 || i>L->length)
		return 0;
	e = L->data[i-1]; // 被删除的元素赋给e
	int j;
	for(j=i; j<L->length; j++)
		L->data[j-1] = L->data[j]; // i位置后的元素前移
	L->length--;
	return 1;
}
~~~

最好O(1) 最坏O(n) 

平均移动次数(n-1)/2 平均O(n)

#### 顺序查找（按值查找）

~~~c
int LocateElem(SqList L, ElemType e){
	int i;
	for(i=0; i<L.length; i++)
		if(L.data[i] == e)
			return i+1; // 下标元素为i的元素等于e，返回i+1
	return 0; // 没找到
}
~~~

最好O(1) 最坏O(n) 

平均移动次数(n+1)/2 平均O(n)

~~~c
#include <stdio.h>
#include <stdlib.h>
#define MAXSIZE 50 // 定义线性表的最大长度

typedef int ElemType;

typedef struct{
    ElemType data[MAXSIZE]; // 顺序表元素
    int length; // 顺序表当前长度
}SqList, *SqListptr; //顺序表的类型定义

int ListInsert(SqListptr L, int i, ElemType e){
	if(i<1 || i>L->length+1) // 无效范围, 临界值可插在1位置和length+1位置处
		return 0;
	if(L->length >= MAXSIZE) // 存储空间已满
		return 0;
    int j;
	for(j=L->length; j>=i; j--)
		L->data[j] = L->data[j-1]; // 将第i个元素之后的元素后移
	L->data[i-1] = e; // 在位置i处放入e
	L->length++;
	return 1;
}

int ListDelete(SqListptr L, int i, ElemType *e){
	if(i<1 || i>L->length)
		return 0;
	e = L->data[i-1]; // 被删除的元素赋给e
	int j;
	for(j=i; j<L->length; j++)
		L->data[j-1] = L->data[j]; // i位置后的元素前移
	L->length--;
	return 1;
}

int LocateElem(SqList L, ElemType e){
	int i;
	for(i=0; i<L.length; i++)
		if(L.data[i] == e)
			return i+1; // 下标元素为i的元素等于e，返回i+1
	return 0; // 没找到
}

main(){
    SqList List;
    List.data[0] = 2;
    List.length = 1;
    SqListptr L = &List;
    int i;
    ElemType *e = (ElemType*)malloc(sizeof(ElemType));
    if(ListInsert(L, 1, 1))
        for(i=0; i<L->length; i++)
            printf("%d\n", L->data[i]);
    printf("loc:%d\n", LocateElem(*L, *e));
    printf("d:%d\n", ListDelete(L, 1, e));
    for(i=0; i<L->length; i++)
            printf("%d\n", L->data[i]);
}
~~~

## 链表

## 单链表

头结点数据域不设任何信息

~~~c
typedef struct LNode{ 
	ElemType data;
	struct LNode *next;
}LNode, *LinkList;
~~~

离散存放，随机存储

### 建表

#### 头插法建立单链表

读入数据的顺序与生成链表中元素的顺序相反

~~~c
LinkList CreatList1(LinkList L){
	// 从表尾到表头逆向建立单链表L，每次均在头结点之后插入元素
	LNode *s;
	L = (LinkList)malloc(sizeof(LNode)); // 创建头结点
	L->next = NULL; // 初始为空链表

	int x;
	scanf("%d", &x); //输入结点的值
	while(x != 9999){
		s = (LinkList)malloc(sizeof(LNode)); // 生成新结点
		s->data = x;
		s->next = L->next;
		L->next = s;
		scanf("%d", &x);
	}
	return L;
}
~~~

每个节点O(1), 表长为n则总的时间复杂度O(n)

#### 尾插法建立单链表

~~~c
LinkList CreatList2(LinkList L){
	// 从表头到表尾正向建立单链表L，每次都在表尾插入元素
	LNode *s;
	L = (LinkList)malloc(sizeof(LNode));
	L->next = NULL;
	LNode *r = L; // r为表尾指针

	int x;
	scanf("%d", &x);
	while(x != 9999){
		s = (LinkList)malloc(sizeof(LNode));
		s->data = x;
		r->next = s;
		r = s; // r指向新的表尾
		scanf("%d", &x);
	}
	r->next = NULL; // 表尾结点置空
	return L;
}
~~~

每个节点O(1), 表长为n则总的时间复杂度O(n)

### 基本操作实现

#### 查找

##### 按序号查找结点值

~~~c
LNode *GetElem(LinkList L, int i){
	LNode *p = L->next;
	if(i == 0)
		return L;
	if(i < 1)
		return NULL;
	int j = 1;
	while(p && j<i){ //返回第i个结点的指针，如果i大于表长，p=NULL
        p = p->next;
        j++;
    }
	return p;
}
~~~

O(n)

##### 按值查找表结点

~~~~c
int LocateElem(LinkList L, ElemType e){
    LNode *p = L->next;
    int i = 1;
    while(p && p->data!=e){
        p = p->next;
        i++;
    }
    if(p == NULL) // p为空则整个表中没有元素e
        return 0;
    else
        return i;
}
~~~~

O(n)

#### 插入结点操作

#####前插 

~~~c
int LInsert(LinkList L, int i, ElemType e){
    LNode *p = GetElem(L, i-1); // 找到待插入位置的前驱结点，即第i-1个结点，在其后插入结点
    if(p == NULL)
        return 0;
    LNode *n = (LinkList)malloc(sizeof(LNode));
    n->data = e;
    n->next = p->next;
    p->next = n;
    return 1;
}
// 注意是查找待插入位置的前驱结点，即第i-1个结点，GetElem(L, i-1)
~~~

开销在于查找第i-1个元素O(n)，若给定结点插入O(1)

##### 后插（这里采用前插操作，但交换数据域顺序，实现逻辑上的后插）

~~~c
int LInsert_(LinkList L, int i, ElemType e){
    LNode *p = GetElem(L, i-1); // 找到待插入位置的前驱结点，即第i-1个结点，在其后插入结点
    if(p == NULL)
        return 0;
    LNode *n = (LinkList)malloc(sizeof(LNode));
    n->data = e;
    n->next = p->next;
    p->next = n;
    ElemType temp;
    temp = n->data;
    n->data = p->data;
    p->data = temp;
    return 1;
}
~~~

#### 删除

~~~c
int LDelete(LinkList L, int i){
    LNode *p = GetElem(L, i-1); // 查找删除位置的前驱结点
    if(p == NULL)
        return 0;
    LNode *q = p->next; // 使q指向被删除的结点
    p->next = q->next;
    free(q);
    return 1;
}
~~~

开销在于查找第i-1个元素O(n)，若给定结点O(1)

#### 求表长

对不带头结点的单列表，当表为空时要单独处理